<!DOCTYPE html>
<html lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1.0">
	<title>ЛР-06</title>
	<link rel="stylesheet" href="main.css">
</head>
<body class="body">
	<header class="header">
		<h3 class="main-title">Функціональне програмування</h3>
	</header>

<div class="dropup">
<div class="dropbtn"></div>
<div class="dropbtn"></div>
<div class="dropbtn"></div>
  <div class="dropup-content">
  	<a href="index.html">Головна</a>
    <a href="lab-01.html">ЛР-01</a>
    <a href="lab-02.html">ЛР-02</a>
    <a href="lab-03.html">ЛР-03</a>
    <a href="lab-04.html">ЛР-04</a>
    <a href="lab-05.html">ЛР-05</a>
    <a href="lab-06.html">ЛР-06</a>
    <a href="lab-07.html">ЛР-07</a>
    <a href="lab-08.html">ЛР-08</a>
  </div>

<div class="main-page">
	<h1 class="lab-01"><b>Лабораторна робота №6</b></h1>
	
	<div class="ssilki"> 
	<p> <li><a href="#theme">Тема</a></li></p>
	<p> <li><a href="#meta">Мета</a> </li></p>
	<p><li><a href="#tasks">Завдання</a></li></p>
	<p><li><a href="#structure">Опис алгоритму для завдання</a></li></p>
	<p><li><a href="#flow-chart">Структура програми</a></li></p>
	<p><li><a href="#language">Обгрунтування вибору середовища та мови</a></li></p>
	<p><li><a href="#code">Код програми</a></li></p>
	<p><li><a href="#screen">Скріншоти результатів</a></li></p>
	<p><li><a href="#conclusions">Висновки</a></li></p>

    </div>


	<p id="theme" class="theme">
	<b>Тема:</b>
	Обробка структур типу векторів і матриць, стеків та черг 
	мовами функціонального програмування

	</p>	

	<p id="meta" class="meta">
	<b>Мета:</b>
	Опанувати теоретичні основи обробки структур типу векторів і матриць, стеків та черг мовами функціонального програмування та розробити програми їх реалізації</p>	
	<div><b>Варіант:</b>
	11</div>
	<div id="tasks" class="tasks">
	<p><b>Завдання:</b></p>
	<p><b>11.1.</b>Створити вектор чисел з додатними, від’ємними та нульовими елементами. Видалити з вектору всі нульові елементи. Решту елементів розмістити так, щоб додатні і від'ємні елементи чергувалися. Надрукувати вектор до та після переміни.</p>
	
	<p><b>11.2</b>У магазині стоїть черга з n покупців. Заданий час обслуговування покупця з черги у вигляді  цілого числа в діапазоні від 1 до t1, та час додавання нового покупця до черги – це ціле число в діапазоні від 1 до t2. Промоделювати стан черги (тобто показати час виникнення подій - обслуговування та додавання покупця) за період часу T (T>t1, T>t2). Вивести на екран залишок черги.</p>
	</div>	

	<div id="structure" class="structure">
		<p class="struct-title"><b>Опис алгоритму для завдання 11.1:   </b>
		<p><p>1. Створюємо функцію, яка повертає список із ненульових елементів<br>
		2. Створюємо функцію, яка повертає список із додатних елементів<br>
		3. Створюємо функцію, яка повертає список із від'ємних елементів<br>
		4. Створюємо функцію, яка повертає новий список, в якому додатні та від'ємні числа чергуються'<br>
		5. Задаємо початковий список у змінну my-list<br>
		6. Задаємо функцію not-zero-list, в яку передаємо функцію, що повертає список із ненульових елементів<br>
		7. Задаємо функцію pos-nums, в яку передаємо функцію, що повертає список із додатних елементів<br>
		8. Задаємо функцію neg-nums, в яку передаємо функцію, що повертає список із від'ємних елементів<br>
		9. Задаємо функцію reslt, в яку передаємо функцію, що повертає список, в якому додатні та від'ємні елементи чергуються<br>
		10. Виводимо результат на екран<br></p> 
		</p>             
		
<p class="struct-title"><b>Опис алгоритму  для завдання 11.2:</b>
		<p>1. Підключаємо бібліотеку для генерування випадкових чисел<br>
		2. Оголошуємо , чи є чега порожньою <br>
		3. Створюємо функцію доступу до першого елементу черги<br>
		4. Створюємо функцію доступу до останнього елементу черги <br>
		5. Створюємо функцію для додавання нового елементу в чергу<br>
		6. Створюємо функцію для видалення елементів з черги<br>
		7. Створюємо функцію, яка перетворює список елементів в чергу<br>
		8. Створюємо функцію, яка запускає процес обслуговування покупців у черзі<br>
		9. Задаємо час для моделювання черги T=30<br>
		10. Створюємо функцію покупців, викликавши з неї функцію для створення черги<br>
		11. Задаємо початкову чергу<br>
		12. Запускаємо процес обслуговування покупців для даної черги з виведенням кожної ітерації на екран<br>
		13. Відображаємо залишок черги<br></p> 
		</p>
</div>
<! -- --> <div id="flow-chart" class="flow-chart">
		<p><b>Структура програми (HIPPO діаграма):</b></p>
		<img src="HIPPO-LR-06(11.1).jpg"><br>
		<img src="HIPPO-LR-06(11.2).jpg">
	</div>
	
	<div id="language" class="language">
		<p>
			<b>Обгрунтування вибору середовища та мови</b>
			<p>В якості середовища було обрано DrRacket версії 8.2 та мова Racket</p>
			<p>Вибір середовища та мови був зумовлений наступним:
			<li>DrRacket та мова Racket  мають хорошу документацію <a href="https://docs.racket-lang.org/" target="_blank">https://docs.racket-lang.org</a></li>
			<li>дане середовище та мова були рекомендовані викладачем</li>
  			</p>
		</p>
	</div>
	<div>
		 <p><b>Код програми:</b></p>
		 <div id="code" class="code">
		 	#lang racket<br>

; #Task 11.1<br>
<br>

(display "\n#Lab-06 Victoria Rimchuk, IPZ-43")<br>
(newline)<br>
<br>
; Функція, яка повертає список із ненульових елементів<br>
(define (delete-zero nums)<br>
  (if (not (null? nums))<br>
      (append (if (= (car nums) 0) '() (list (car nums)))<br>
              (delete-zero (cdr nums)))<br>
      '()))<br>
<br>
; Функція, яка повертає список із додатних елементів<br>
(define (positive-nums nums)<br>
  (if (not (null? nums))<br>
      (append (if (< (car nums) 0) '() (list (car nums)))<br>
              (positive-nums (cdr nums)))<br>
      '()))<br>
<br><br>
; Функція, яка повертає список із від'ємних елементів<br>
(define (negative-nums nums)<br>
  (if (not (null? nums))<br>
      (append (if (> (car nums) 0) '() (list (car nums)))<br>
              (negative-nums (cdr nums)))<br>
      '()))<br>
<br>
; функція,яка повертає новий список, в якому додатні та від'ємні числа чергуються<br>
(define (main nums1 nums2)<br>
  (if (or (not (null? nums1))<br>
          (not (null? nums2)))<br>
      (append<br>
       (append<br>
        (if (not (null? nums1)) (list (car nums1)) '())<br>
        (if (not (null? nums2)) (list (car nums2)) '()))<br>
       (main (if (not (null? nums1)) (cdr nums1) nums1)<br>
                    (if (not (null? nums2)) (cdr nums2) nums2)))<br>
      '()))<br>
<br>
<br>
(define my-list (list 2 -1 3 0 5 0 12 -6))<br>
(define not-zero-list (delete-zero my-list))<br>
(define pos-nums (positive-nums not-zero-list))<br>
(define neg-nums (negative-nums not-zero-list))<br>
(define result (main pos-nums neg-nums))<br>
<br>
(display "#Task 11.1\n")<br>
(display "Початковий список:")<br> 
(newline)<br>
(display my-list) (newline)<br>
(display "Список без нульових елементів:")<br> 
(newline)<br>
(display not-zero-list)<br> 
(newline)<br>
(display "Список  в якому додатні та від'ємні числа чергуються:")<br>
(newline)<br>
(display result)<br>
(newline)<br>
<br>
<br>
; Task 11.2<br>
<br>
(#%require srfi/27)<br>
<br>
;Оголошення черги<br>
(define (make-queue)<br>
 (define p (cons '() '() ) )<br>
 (cons p p)<br>
)<br>
;Перевірка, чи є черга порожньою<br>
(define (null-queue? q)<br>
 (and<br>
  (eq? (front q) (rear q)) (eq? (car (front q)) '() ))<br>
)<br>
;доступ до першого елемента черги<br>
(define (front q)<br>
 (car q)) <br>
;доступ до останнього елемента черги<br>
(define (rear q)<br>
 (cdr q))<br>
<br>
;додавання нового елемента в чергу<br>
(define (push q e)<br>
 (define p (cons e '()))<br>
 (if (null-queue? q)<br>
  (begin<br>
    (set-car! q p)<br>
    (set-cdr! q p))<br>
  (begin<br>
   (set-cdr! (rear q) p)<br>
   (set-cdr! q p))))<br>
<br>
;видалення елемента з черги<br>
(define (pop q)<br>
 (define x 0)<br>
 (if (null-queue? q)<br>
  'Empty    ;==== виведення повідомдення про порожню чергу<br>
  (if (and (eq? (front q) (rear q))  (eq? '() (cdr (front q))))<br>
   (begin<br>
    (set! x (car (front q)))<br>
    (set-car! (front q) '() )<br>
    x )<br> 
   (begin<br>
    (set! x (car (front q)))<br>
    (set-car! q (cdr (front q)) )<br>
    x))))<br>
<br>
; функція, яка перетворює список елементів в чергу<br>
(define (list->qu qu my-list)<br>
  (if (not (null? my-list))<br>
      (begin<br>
        (push qu (car my-list))<br>
        (list->qu qu (cdr my-list)))))<br>
<br>
(define (run qu T x1 x2)<br>
  (define t1 5)<br>
  (define t2 6)<br>
  (if (and (not (null? qu))<br>
           (> T 0))<br>
      (begin<br>
        (if (= x1 0)<br>
            (begin<br>
              (display "Чергу покинув покупець: ")<br>
              (display (pop qu))<br>
              (newline)))<br>
        (if (= x2 0)<br>
            (let ((new-customer (random-integer 20)))<br>
              (display "В чергу став покупець: ")<br>
              (display new-customer)<br>
              (newline)<br>
              (push qu new-customer)))<br>
        (run qu<br>
             (- T 1)<br>
             (if (= x1 0)<br>
                 (+ 1 (random-integer t1))<br>
                 (- x1 1))<br>
             (if (= x2 0)<br>
                 (+ 1 (random-integer t2))<br>
                 (- x2 1))))))<br>
<br>
(define T 30)<br>
(define customers (make-queue))<br>
(list->qu customers (list 7 3 2 4)) ; задаємо початкову чергу<br>
<br>
<br>
(display "\n#Task 11.2\n")<br>
(run customers T 2 3)<br>
<br>
(display "\nЗалишок черги:\n")<br>
(display (car customers))<br>
	</div>
	<div id="screen" class="screen">
		<p><b>Скріншот результатів:</b></p>
		<img src="lab-06-results.jpg">
	</div>
	<div><p><b>Аналіз достовірності результатів:</b></p>
		<p>11.1 Оскільки, завдання полягало у реалізації базових операцій роботи з векторами (видалення, сортування) перевірку на достовірність було проведено за допомогою візуальної оцінки вектору після кожної дій над ним. На мою думку, дане завдання не потребує додаткових перевірок на достовірність.
		</p>
		<p>11.2 Для даного завдання, аналогічно із попереднім, перевірку на достовірність було проведено за допомогою візуальної оцінки черги після кожної дій над нею. На мою думку, дане завдання не потребує додаткових перевірок на достовірність.
		</p>
		
	</div>
	<div id="conclusions" class="conclusions">
	<p><b>Висновки:</b></p>
	<p>В ході виконання даної лабораторної роботи було опановано теоретичні основи обробки структур типу векторів і матриць, стеків та черг мовами функціонального програмування шляхом реалізації програм для вирішення завдань згідно варіанту. 

	</p>
</div>
</div>
</body>
</html>